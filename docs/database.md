<h1>数据库的架构</h1>
<h1>为什么使用索引,索引越多越好吗，索引有哪些结构</h1>
创建索引可以加快数据的检索速度（不创建索引，数据库查询默认进行全表扫描)。
但是
*数据量小不需要建立索引。（数据量超过300）
*创建和维护索引需要耗费时间。这种时间随着数据量的增大而增大。
*索引需要占据物理空间，如果索引建立过多，。
*当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
<h2 style="color:blue">索引的结构</h3> 
*B+树，常用，可以进行范围差值，单值查询。以及排序
*hash索引：只能用于单值查询，不能排序和范围查询。
*位图索引：位图表示的索引，对列的每个键值建立一个位图。适合
select count(XX) 时,可以直接访问索引中一个位图就快速得出统计数据；
当根据键值做and，or或 in(x,y,..)。
<h1>什么样的信息能成为索引</h1>
1表的主键和外键，唯一键，具有一定的 区分性。<br>
2经常与其他表进行连接的表，在连接字段上应该建立索引。<br>
3索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引。<br>
4索引应该建在选择性高的字段上<br>

<h1>密集索引和稀疏索引的区别</h1>
*'密集索引'：叶子节点保存的不只是键值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引。<br>
*'稀疏索引'：稀疏索引文件中只为搜索码的某些值建立索引项 这可以理解为叶子结点只保存了键位信息以及该行数据的地址，有的稀疏索引只保存了键位信息主键。
*区别：<br>
稀疏索引占用的索引存储空间比较小，但是查找时间较长；<br>
密集索引索引查找时间较短，索引存储空间较大。
myIsam：主键索引，唯一键索引，还是普通索引 —都是 稀疏索引。<br>
在Innodb中 有且仅有一个密集索引 
Innodb中选取规则：
(1)、如果一个主键被定义了 则该主键作为密集索引
(2)、若该主键没有被定义 则该表的第一个唯一非空索引作为密集索引
(3)、若不满足上述条件 则innodb内部会生成一个隐藏主键(密集索引)
(4)、非主键索引存储相关键位和其对应的主键值 包含两次查找：通过辅助索引找到主键，再根据主键在密集索引中找到数据。
#如何定位并优化慢查询sql
*根据慢日志定位慢查询sql<br>
1show variables like "%query%"(查看查询设置,mysql 默认慢查询为10秒)
2.show status like "%slow_queries%"(显示慢查询的数量)
3set  global shlow_query_log=on(打开慢查询日志)
4set globallong_query_time=1;(设置慢查询为1秒，数据库重启后，失效)
*使用explain分析sql<br>
3个关键字：type查询的类型（全表扫描还是索引等）;extra;

*使sql尽量走索引
#hash索引和b+树的区别
#最左前缀匹配原则

#锁
##MyISAM的引擎和INNODB锁的区别
*MyISAM默认使用表级锁，不支持行级锁。
*InnoDB默认用的行级锁，也支持表级锁。
##乐观锁，悲观锁，共享锁，排他锁。 
##MYISAM的应用场景和INOODB应用场景
*MYISAM
适合频繁执行全表的count语句（通过一个变量保存整个表的行数）。
适合对数据增删改频率不高（会涉及到表锁），查询频率高。
适合没有事务的。
*InnoDB应用场景
数据增删改频率比较高。
可靠性要求比较高，要求支持事务。
#事务#
是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位.
##数据库事务的四大特性
ACID
*`Atomic`:原子性事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库产生影响；
*`Consistency`:一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000。
*`Isolation`:隔离性是指当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离；
*`Durability`:持久性一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。

##事务的并发访问的问题以及事务的隔离机制。	
*`脏读`：是指个事务处理过程里读取了另一个未提交的事务中的数据然后使用了这个数据。
*`不可重复读`：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
*`幻读`：当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行修改，这种数据涉及到表中的全部数据行，同时，第二个事务也对这个表数据进行修改，这个修改是对表中新增/删除一条数据，那么操作第一个事务的用户发现表中的数据还没有修改的数据行，就好像发生了幻觉一样，这就是发生了幻读。
注:幻读和不可重复读都读取另一条已经提交的事务，所不同的是不可重复读查询的都是同一数据项，而幻读针对的是一批数据整体。
##隔离级别：
数据库提供的四种隔离级别：
*`Read uncommitted(读未提交)`：最低级别，任何情况都会发生。
*`Read Committed(读已提交)`：可避免脏读的发生，会发生不可重复读。
*`Repeatable read(可重复读)`：可避免脏读、不可重复读的发生。
*`Serializable(串行化)`：避免脏读、不可重复读，幻读的发生。
#InooDB下RR级别如何避免幻读
##next-key锁：行锁+Gap锁
##gap锁：
